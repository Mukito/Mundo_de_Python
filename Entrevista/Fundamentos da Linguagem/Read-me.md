## üìå Qual a diferen√ßa entre listas e tuplas em Python?

A principal diferen√ßa entre **listas** e **tuplas** em Python est√° na **mutabilidade**:

* **Listas** (`list`) s√£o **mut√°veis**, ou seja, podem ser modificadas ap√≥s a cria√ß√£o. Voc√™ pode adicionar, remover ou alterar elementos.

* **Tuplas** (`tuple`) s√£o **imut√°veis**, ou seja, depois de criadas, seus elementos n√£o podem ser alterados.

### Exemplo de lista (mut√°vel)

```
lista = [1, 2, 3]
lista.append(4)  # Adiciona um elemento
lista[0] = 99    # Modifica um elemento
print(lista)  # Sa√≠da: [99, 2, 3, 4]
```

### Exemplo de tupla (imut√°vel)

```
tupla = (1, 2, 3)
tupla[0] = 99  # Erro! Tuplas n√£o podem ser modificadas
```

### Sa√≠da:

```
TypeError: 'tuple' object does not support item assignment
```

## Outras diferen√ßas importantes<br>


|**Caracter√≠stica**	 |  **Lista** (`list`)	 |  **Tupla** (`tuple`)  |
|--------------------|-----------------------|-----------------------|
|**Mutabilidade**	 |  Mut√°vel	 |  Imut√°vel  |
|**Velocidade**  |  Mais lenta	 |  Mais r√°pida (menos sobrecarga de mem√≥ria)  |
|**Uso de mem√≥ria**  |  Ocupa mais espa√ßo  |  Ocupa menos espa√ßo  |
|**Seguran√ßa**  |  Pode ser alterada acidentalmente	 |  Protege dados contra modifica√ß√µes  |
|**M√©todos**  |  `.append()`, `.remove()`, `.sort()`, etc.	|  Apenas `.count()` e `.index()` |

### Quando usar cada uma?
* Use **listas** quando precisar modificar os dados com frequ√™ncia.

* Use **tuplas** quando precisar garantir que os dados permane√ßam inalterados (exemplo: coordenadas de um ponto, dias da semana, chaves de dicion√°rio).


## üìå O que s√£o dicion√°rios e como funcionam?

Os **dicion√°rios** (`dict`) em Python s√£o estruturas de dados que armazenam pares **chave-valor**. Eles s√£o **mut√°veis**, ou seja, podem ser alterados ap√≥s a cria√ß√£o, e permitem acesso r√°pido aos valores atrav√©s de suas chaves.

### üîπ Sintaxe de um dicion√°rio  
```python
# Criando um dicion√°rio
dados = {
    "nome": "Alice",
    "idade": 25,
    "cidade": "S√£o Paulo"
}

# Acessando valores
print(dados["nome"])  # Sa√≠da: Alice

# Adicionando um novo par chave-valor
dados["profissao"] = "Engenheira"

# Modificando um valor existente
dados["idade"] = 26

# Removendo um item
del dados["cidade"]

# Verificando se uma chave existe
if "nome" in dados:
    print("Nome est√° presente!")
```

### üîπ Principal caracter√≠sticas

- ‚úÖ **Mut√°veis** ‚Üí Voc√™ pode adicionar, modificar e remover elementos.
- ‚úÖ **Chaves √∫nicas** ‚Üí Cada chave deve ser √∫nica dentro do dicion√°rio.
- ‚úÖ **Acesso r√°pido** ‚Üí O acesso aos valores √© feito via chave, e n√£o por √≠ndices como em listas.
- ‚úÖ **N√£o ordenados (at√© Python 3.6)** ‚Üí A partir do Python 3.7, a ordem de inser√ß√£o das chaves √© mantida.

### üîπ M√©todos √∫teis
```
dados.keys()   # Retorna todas as chaves
dados.values() # Retorna todos os valores
dados.items()  # Retorna pares chave-valor
dados.get("nome", "N√£o encontrado") # Evita erro se a chave n√£o existir
dados.pop("idade")  # Remove um item e retorna o valor removido
dados.clear()  # Apaga todos os elementos do dicion√°rio
```
### üîπ Exemplo de uso em um loop
```
for chave, valor in dados.items():
    print(f"{chave}: {valor}")

```
 **Sa√≠da**

```
nome: Alice  
profissao: Engenheira  

```

### üîπ Compara√ß√£o entre dicion√°rios e outras estruturas

| **Caracter√≠stica**	 |  Lista (`list`)	|  Tupla (`tuple`)  |	Dicion√°rio (`dict`) |
|----------------------|----------------|-----------------|-------------------|
| **Mutabilidade**  |  Mut√°vel  |	Imut√°vel  |	 Mut√°vel  |
| **Velocidade**	 |  M√©dia	 | R√°pida	| Muito r√°pida para acesso por chave |
| **Uso de mem√≥ria**  | 	Ocupa mais espa√ßo |	Ocupa menos espa√ßo |	Ocupa mais espa√ßo devido √† indexa√ß√£o |
| **Acesso aos dados**	 |  Via √≠ndice (`list[0]`) |	Via √≠ndice (`tuple[0]`)	| Via chave (`dict["chave"]`) |
| **Ordem garantida**	 |  Sim (desde Python 3.7)	| Sim	 | Sim (desde Python 3.7) |
| **Casos de uso**	 |  Listas de itens variados	| Dados constantes, coordenadas |	Estruturas associativas (JSON, APIs) |

Os dicion√°rios s√£o muito √∫teis para armazenar dados estruturados, como JSONs, e s√£o amplamente usados em APIs e manipula√ß√£o de dados.

## üìå Qual a diferen√ßa entre `deepcopy` e `copy` no m√≥dulo *copy*?
O m√≥dulo `copy` do Python fornece duas formas de copiar objetos:

* `copy.copy(obj)` ‚Üí Faz uma **c√≥pia rasa (shallow copy)**

* `copy.deepcopy(obj)` ‚Üí Faz uma **c√≥pia profunda (deep copy)**
-------------------------------------------------------------

### üîπ 1. C√≥pia rasa (`copy.copy()`)
A **shallow copy** copia apenas a **estrutura externa** do objeto. Se o objeto contiver refer√™ncias a outros objetos (listas dentro de listas, por exemplo), essas refer√™ncias n√£o s√£o copiadas, apenas reutilizadas.

#### Exemplo de copy.copy()

```
import copy

lista_original = [[1, 2, 3], [4, 5, 6]]
lista_copiada = copy.copy(lista_original)

lista_copiada[0][0] = 99  # Modificando um elemento dentro da lista

print(lista_original)  # Sa√≠da: [[99, 2, 3], [4, 5, 6]]
print(lista_copiada)   # Sa√≠da: [[99, 2, 3], [4, 5, 6]]
```
‚úÖ **Conclus√£o**: Como `copy.copy()` copia apenas a refer√™ncia para os subelementos, modificar um subelemento em uma das listas reflete na outra.

------------------------------------------------------------------------------------

### üîπ 2. C√≥pia profunda (`copy.deepcopy()`)
A **deep copy** copia **toda a estrutura do objeto**, incluindo objetos aninhados, garantindo que as c√≥pias sejam totalmente independentes.

### Exemplo de `copy.deepcopy()`

```
import copy

lista_original = [[1, 2, 3], [4, 5, 6]]
lista_copiada = copy.deepcopy(lista_original)

lista_copiada[0][0] = 99  # Modificando um elemento dentro da lista copiada

print(lista_original)  # Sa√≠da: [[1, 2, 3], [4, 5, 6]]
print(lista_copiada)   # Sa√≠da: [[99, 2, 3], [4, 5, 6]]

```
‚úÖ **Conclus√£o**: Como `copy.deepcopy()` copia **toda a estrutura** do objeto, a modifica√ß√£o na c√≥pia **n√£o afeta o original**.

--------------------------------------------------------------------------------

### üîπ Resumo das diferen√ßas

|M√©todo	|Tipo de C√≥pia	|C√≥pia dos Subobjetos?	|Independente?|
|-------|---------------|-----------------------|-------------|
|`copy.copy()`	|C√≥pia rasa (shallow)	|N√£o (mant√©m refer√™ncias)	|N√£o, pois objetos aninhados ainda s√£o compartilhados|
|`copy.deepcopy()`	|C√≥pia profunda (deep)	|Sim (cria novos objetos)|	Sim, pois toda a estrutura √© copiada|

-------------------------------------------------------------------------------------
### Quando usar cada um?
* Use `copy.copy()` ‚Üí Quando seu objeto **n√£o cont√©m objetos mut√°veis internos** ou voc√™ quer apenas copiar a estrutura principal.

* Use `copy.deepcopy()` ‚Üí Quando seu objeto cont√©m **listas, dicion√°rios ou outras estruturas mut√°veis** dentro dele e voc√™ precisa garantir que as c√≥pias sejam independentes.

## üìåComo funciona o gerenciamento de mem√≥ria no Python?

----------------------------------------------------------------------
O **Python gerencia a mem√≥ria automaticamente** atrav√©s de um sistema que inclui **aloca√ß√£o din√¢mica**, **contagem de refer√™ncias** e um **coletor de lixo (Garbage Collector - GC)**.

### üîπ 1. Como a mem√≥ria √© alocada no Python?
O Python organiza a mem√≥ria em **duas grandes √°reas**:

1. **Stack (Pilha)**:

 * Usada para armazenar vari√°veis locais e chamadas de fun√ß√£o.

 * O gerenciamento √© feito automaticamente quando fun√ß√µes entram e saem da execu√ß√£o.

2. **Heap (Montante)**:

 * Onde ficam armazenados objetos e estruturas de dados din√¢micos (listas, dicion√°rios, inst√¢ncias de classes, etc.).

 * O Python usa um sistema de **pools de mem√≥ria** para reutilizar pequenos objetos e evitar fragmenta√ß√£o.

------------------------------------------------------------------------------------------------

## üîπ 2. Contagem de Refer√™ncias (`refcount`)
Cada objeto em Python tem um **contador de refer√™ncias**, que indica quantas vari√°veis ou estruturas est√£o apontando para ele.

### Exemplo:
```
import sys

a = [1, 2, 3]  # Cria√ß√£o da lista
b = a          # 'b' agora aponta para a mesma lista de 'a'

print(sys.getrefcount(a))  # Sa√≠da: 3 (a, b e a chamada do m√©todo contam)

```

* Se a contagem de refer√™ncias chegar a **zero**, o objeto √© removido da mem√≥ria.

---------------------------------------------------------------------------------------------------

## üîπ 3. Coletor de Lixo (Garbage Collector)
O Python possui um **coletor de lixo autom√°tico** (`gc`), que remove objetos √≥rf√£os da mem√≥ria.
Isso ocorre principalmente em **casos de refer√™ncias circulares**, onde objetos apontam uns para os outros, impedindo a libera√ß√£o autom√°tica.

### Exemplo de refer√™ncia circular (problema):
```
import gc

class A:
    def __init__(self):
        self.ref = None

obj1 = A()
obj2 = A()

obj1.ref = obj2  # obj1 aponta para obj2
obj2.ref = obj1  # obj2 aponta para obj1

del obj1
del obj2

gc.collect()  # For√ßa a remo√ß√£o de objetos √≥rf√£os
```
* Sem o `gc.collect()`, os objetos poderiam ficar presos na mem√≥ria.

---------------------------------------------------------------------------------------------------

## üîπ 4. Otimiza√ß√µes do Python
####üìç Small Object Pooling
O Python reutiliza pequenos inteiros e strings imut√°veis para melhorar a performance.

### Exemplo:
```
a = 10
b = 10
print(a is b)  # Sa√≠da: True (mesmo objeto na mem√≥ria)

x = 300
y = 300
print(x is y)  # Sa√≠da: False (inteiros maiores podem ser alocados separadamente)

```
* Inteiros de -5 a 256 s√£o reutilizados.

------------------------------------------------------------------------------------------------

#### üìç String Interning
Strings imut√°veis pequenas e sem espa√ßos podem ser armazenadas no cache.

### Exemplo:
```
s1 = "Python"
s2 = "Python"
print(s1 is s2)  # Sa√≠da: True (mesmo objeto)

```
---------------------------------------------------------------------------------------------------

## üîπ 5. Como melhorar o uso da mem√≥ria no Python?
#### ‚úÖ Evite refer√™ncias desnecess√°rias:
```
a = [1, 2, 3]
b = a
del a  # 'b' ainda mant√©m a lista na mem√≥ria
```
#### ‚úÖ Use `del` e `gc.collect()` para liberar mem√≥ria:
```
import gc
del obj
gc.collect()
```

#### ‚úÖ Prefira gerenciadores de contexto (`with`)
```
with open("arquivo.txt") as f:
    dados = f.read()  # Arquivo fechado automaticamente
```

#### ‚úÖ Utilize __slots__ para otimizar classes
```
class Pessoa:
    __slots__ = ['nome', 'idade']  # Reduz o uso de mem√≥ria ao evitar dicion√°rios internos

p = Pessoa()
p.nome = "Alice"
p.idade = 25

```

----------------------------------------------------------------------------------------------------

## üîπ **Resumo**

| Mecanismo                  | Fun√ß√£o                                                    |
|----------------------------|-----------------------------------------------------------|
| **Stack (Pilha)**          | Armazena vari√°veis locais e chamadas de fun√ß√£o           |
| **Heap (Montante)**        | Armazena objetos e estruturas de dados din√¢micas         |
| **Contagem de Refer√™ncias** | Libera automaticamente objetos sem refer√™ncias          |
| **Garbage Collector (`gc`)** | Remove objetos √≥rf√£os para evitar vazamento de mem√≥ria |
| **Small Object Pooling**   | Reutiliza pequenos inteiros e strings para otimizar o uso de mem√≥ria |

O gerenciamento de mem√≥ria do Python √© autom√°tico, mas **boas pr√°ticas podem ajudar a otimizar o desempenho e evitar consumo excessivo**. üöÄ


## üìåO que s√£o List Comprehensions e como us√°-las?

**List Comprehension** √© uma forma concisa e eficiente de criar listas em Python. Em vez de usar loops `for` convencionais, podemos gerar listas em **uma √∫nica linha de c√≥digo**, tornando o c√≥digo mais **limpo** e **perform√°tico**.

____________________________

## üîπ 1. Sintaxe B√°sica
A sintaxe de uma List Comprehension √©:
```
[express√£o for item in iter√°vel if condi√ß√£o]
```
* `express√£o` ‚Üí Define como cada elemento ser√° processado.

* `for item in iter√°vel` ‚Üí Percorre a estrutura de dados.

* `if condi√ß√£o (opcional)` ‚Üí Filtra os elementos.

__________________________________

## üîπ 2. Exemplos Pr√°ticos
#### üìç Criando uma lista sem List Comprehension
```
numeros = []
for i in range(10):
    numeros.append(i * 2)

print(numeros)  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```
#### üìç Criando a mesma lista com List Comprehension

```
numeros = [i * 2 for i in range(10)]
print(numeros)  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

#### ‚úÖ Resultado id√™ntico, mas com menos c√≥digo!

_______________________________________________

## üîπ 3. Usando if para Filtragem
#### üìç Pegando apenas n√∫meros pares de 0 a 9
```
pares = [i for i in range(10) if i % 2 == 0]
print(pares)  # [0, 2, 4, 6, 8]
```
#### üìç Pegando n√∫meros maiores que 5 de uma lista
```
numeros = [1, 5, 8, 12, 3, 7]
maiores = [n for n in numeros if n > 5]
print(maiores)  # [8, 12, 7]
```
________________________________________________________
## üîπ 4. Usando if...else Dentro da List Comprehension
#### üìç Convertendo n√∫meros em "Par" ou "√çmpar"
```
resultado = ["Par" if i % 2 == 0 else "√çmpar" for i in range(5)]
print(resultado)  # ['Par', '√çmpar', 'Par', '√çmpar', 'Par']
```

## üîπ 5. List Comprehension com M√∫ltiplos for
#### üìç Criando pares de n√∫meros de duas listas
```
pares = [(x, y) for x in range(3) for y in range(3)]
print(pares)
# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
```

## üîπ 6. List Comprehension com Fun√ß√µes
#### üìç Convertendo palavras para mai√∫sculas
```
palavras = ["python", "lista", "comprehension"]
maiusculas = [palavra.upper() for palavra in palavras]
print(maiusculas)  # ['PYTHON', 'LISTA', 'COMPREHENSION']
```
#### üìç Calculando o quadrado de n√∫meros
```
def quadrado(n):
    return n ** 2

quadrados = [quadrado(x) for x in range(6)]
print(quadrados)  # [0, 1, 4, 9, 16, 25]
```

_____________________________________________________________


## üîπ 7. Compara√ß√£o de Performance
#### üìç List Comprehension √© mais r√°pida do que loops tradicionais!
```
import time

# Usando um loop for
inicio = time.time()
lista1 = []
for i in range(10**6):
    lista1.append(i * 2)
print("Loop for:", time.time() - inicio)

# Usando List Comprehension
inicio = time.time()
lista2 = [i * 2 for i in range(10**6)]
print("List Comprehension:", time.time() - inicio)
```
#### ‚úÖ **Resultado**: List Comprehension √© significativamente mais r√°pida! üöÄ

_______________________________________________________________________


## üîπ 8. Quando Usar List Comprehensions?
#### ‚úÖ Quando melhora a legibilidade
#### ‚úÖ Quando precisa de performance
#### ‚úÖ Quando o c√≥digo pode ser reduzido sem perder clareza

#### **Evite List Comprehensions quando a l√≥gica for muito complexa**, pois pode reduzir a legibilidade do c√≥digo.

_______________________________________________________________________

## üîπ Resumo

| **Conceito**	 |  Explica√ß√£o  |
|----------------|--------------|
| **Sintaxe** 	|  `[express√£o for item in iter√°vel if condi√ß√£o]`  |
| **Vantagens**  |	 C√≥digo mais limpo, leg√≠vel e eficiente  |
| **Com `if`**	 |  `[x for x in lista if x > 5]`  |
| **Com `if...else`**  |	 `["Par" if x % 2 == 0 else "√çmpar" for x in lista]`  |
| **Com m√∫ltiplos loops**  |	 `[(x, y) for x in range(3) for y in range(3)]`  |
| **Com fun√ß√µes**  |	 `[fun√ß√£o(x) for x in lista]`  |

#### üîπ List Comprehension √© uma das melhores t√©cnicas para otimizar c√≥digo Python! üöÄ









